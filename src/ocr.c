/* $Id: ocr.c,v 1.2 1999/01/03 02:07:27 sybalsky Exp $ (C) Copyright Venue, All Rights Reserved  */

/************************************************************************/
/*									*/
/*	(C) Copyright 1989-95 Venue. All Rights Reserved.		*/
/*	Manufactured in the United States of America.			*/
/*									*/
/************************************************************************/

#include "version.h"

#ifdef OCR

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <setjmp.h>
#include <string.h>
#include <stdio.h>
#include "adr68k.h"
#include "lispmap.h"
#include "lispemul.h"
#include "lsptypes.h"
#include "lspglob.h"
#include "cell.h"
#include "arith.h"
#include "timeout.h"
#include "ocr.h"

/*
 * Socket descriptor to communicate with the OCR process
 */

int OCR_sock = -1;
u_int shifted_OCR_sock;

/*
 * OCR process ID
 */

int OCR_procID = -1;

/*
 * Lisp I/F to indicate wait status.
 * Points to the value cell of IL:\OCR.STATE.FLAGS
 */

LispPTR *OCR_state_word = NULL;

/*
 * Other Lisp I/F area
 */

struct ocr_image_info *OCR_iminfo_block = NULL;

/*
 * Image size cache
 */

static u_int OCR_image_size = 0;

/*
 * Local Definitions for clarify code
 */

#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#endif

#define NULL_STATE_WORD (OCR_state_word == NULL)

#define WAITING_REASON (*(u_int *)Addr68k_from_LADDR(*OCR_state_word))

#define INIT_STATE_WORD                                                  \
  {                                                                      \
    DLword an;                                                           \
    extern int get_package_atom();                                       \
    an = get_package_atom("\\OCR.STATE.FLAGS", 16, "INTERLISP", 9, NIL); \
    OCR_state_word = GetDEFCELL68k(an);                                  \
  }

#define SET_WAIT_FLG(reason)                              \
  {                                                       \
    u_int *flagp;                                         \
    flagp = (u_int *)Addr68k_from_LADDR(*OCR_state_word); \
    *flagp = reason;                                      \
  }

#define CLR_WAIT_FLG                                      \
  {                                                       \
    u_int *flagp;                                         \
    flagp = (u_int *)Addr68k_from_LADDR(*OCR_state_word); \
    *flagp = 0;                                           \
  }

#define FD_BLOCK 1
#define FD_NON_BLOCK 0

/*
 * Local Functions
 */

static int ocr_open(), ocr_scan(), ocr_iminfo(), ocr_fork();
static int ocr_block_mode(), ocr_bulk_read(), ocr_wait();
static int ocr_set_rpara(), ocr_read();
static void ocr_close(), ocr_sig_handler(), ocr_irq(), ocr_set_handler();
static void ocr_clr_handler(), ocr_device_reset();
static void ocr_scan_finish(), ocr_img_upld_finish(), ocr_read_finish();
static void ocr_code_conv();
static LispPTR ocr_get_read_result();

/*
 * Subr OCR_COMM:
 *
 * According to the command indicated by args[0], dispatch to the appropriate
 * routines.  Each subroutine should return one of 1, 0 and -1 as its value.
 * 1 means the command is completed successfully.  0 means the command is failed
 * but the OCR process is still alive.  -1 means the command is failed and
 * OCR process seems dead.  In -1 case, issue an interrupt request with interrupt
 * mode OCR_ST_PROC_DEAD.  This causes Lisp fall into a debugger after establishing
 * unwind protected contour to reset OCR.
 */

int ocr_comm(LispPTR *args)
{
  int com;
  LispPTR val;

  N_GETNUMBER(args[0], com, INVAL);
  switch (com) {
    case DO_OPEN:
      if (OCR_sock >= 0) {
        val = GetSmallp(0);
      } else {
        val = ocr_open();
        if (val > 0) {
          val = GetSmallp(val);
        } else {
          val = GetSmallp(0);
        }
      }
      break;

    case DO_SCAN: {
      switch (ocr_scan((struct ocr_scan_para *)Addr68k_from_LADDR(args[1]))) {
        case 1: val = ATOM_T; break;

        case -1:
          val = NIL;
          SET_WAIT_FLG(OCR_ST_PROC_DEAD);
          ocr_irq();
          break;

        case 0:
        default: val = NIL;
      }
    } break;

    case DO_IMG_INFO:
      if (OCR_sock < 0) {
        val = NIL;
      } else {
        OCR_iminfo_block = (struct ocr_image_info *)Addr68k_from_LADDR(args[2]);

        switch (ocr_iminfo((struct ocr_up_para *)Addr68k_from_LADDR(args[1]))) {
          case 1: val = ATOM_T; break;

          case -1:
            val = NIL;
            SET_WAIT_FLG(OCR_ST_PROC_DEAD);
            ocr_irq();
            break;

          case 0:
          default: val = NIL;
        }
      }
      break;

    case DO_IMG_UPLD: {
      BITMAP *bmp;
      int len;

      bmp = (BITMAP *)Addr68k_from_LADDR(args[1]);

      len = ocr_bulk_read(OCR_sock, (char *)Addr68k_from_LADDR(bmp->bmbase), 10);
      val = (len < 0) ? NIL : ATOM_T;
    } break;

    case DO_SET_RPARA: {
      int cnt;
      u_char *pp;

      pp = (u_char *)Addr68k_from_LADDR(args[1]);
      N_GETNUMBER(args[2], cnt, INVAL);

      switch (ocr_set_rpara(pp, cnt)) {
        case 1: val = ATOM_T; break;

        case -1:
          val = NIL;
          SET_WAIT_FLG(OCR_ST_PROC_DEAD);
          ocr_irq();
          break;

        case 0:
        default: val = NIL;
      }
    } break;

    case DO_CLR_RPARA: {
      switch (ocr_clr_rpara()) {
        case 1: val = ATOM_T; break;

        case -1:
          val = NIL;
          SET_WAIT_FLG(OCR_ST_PROC_DEAD);
          ocr_irq();
          break;

        case 0:
        default: val = NIL;
      }
    } break;

    case DO_READ: {
      switch (ocr_read()) {
        case 1: val = ATOM_T; break;

        case -1:
          val = NIL;
          SET_WAIT_FLG(OCR_ST_PROC_DEAD);
          ocr_irq();
          break;

        case 0:
        default: val = NIL;
      }
    } break;

    case DO_GET_RESULT:
      if (OCR_sock < 0) {
        val = NIL;
      } else {
        val = ocr_get_read_result(OCR_sock);
      }
      break;

    case DO_CLOSE:
      if (OCR_sock < 0) {
        val = NIL;
      } else {
        ocr_close();
        val = ATOM_T;
      }
      break;

    case DO_CODE_CONV: {
      int len;
      N_GETNUMBER(args[1], len, INVAL);
      ocr_code_conv((u_char *)Addr68k_from_LADDR(args[2]), len);
      val = ATOM_T;
    } break;

    case DO_TEST: {
      extern DLword *createcell68k();
      u_char *np, *np2;
      LispPTR lp;

      np = (u_char *)createcell68k(TYPE_VMEMPAGEP);
      np2 = (u_char *)createcell68k(TYPE_VMEMPAGEP);
      lp = cons(LADDR_from_68k(np2), NIL);
      lp = cons(LADDR_from_68k(np), lp);
      val = lp;
    } break;

    default: error("ocr_comm: Invalid Comm byte");
  }
  return (val);
INVAL:
  return (NIL);
}

/*
 * Subr OCR_COMM: comm = OCR_OPEN
 *
 * Fork OCR process and isssue 'O' command to open OCR device.
 */

static int ocr_open() {
  int cnt;
  u_char pkt[PKTLEN];

  OCR_sock = ocr_fork();
  if (OCR_sock < 0) {
    return 0;
  } else {
    if (!ocr_block_mode(OCR_sock, FD_BLOCK)) return 0;
    pkt[0] = 'O';
    pkt[1] = pkt[2] = 0;
    if (write(OCR_sock, pkt, sizeof(pkt)) < 0) {
      ocr_close();
      return 0;
    }

    SETJMP(0);

    S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 20);
    if (cnt == sizeof(pkt) && pkt[0] == 1) {
      if (NULL_STATE_WORD) INIT_STATE_WORD;
      ocr_set_handler();
      shifted_OCR_sock = 1 << OCR_sock;
      return (OCR_sock);
    } else {
      return 0;
    }
  }
}

/*
 * Ask the pre-forked small emulator process to fork the OCR process
 */

static int ocr_fork() {
  int sfd, nsfd;
  char *addr;
  int len, flag;
  struct sockaddr_un sock;
  u_char pkt[4];
  extern char *build_socket_pathname();
  extern int UnixPipeIn, UnixPipeOut;

  sfd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sfd < 0) {
    perror("ocr_fork: socket open");
    return -1;
  }

  addr = build_socket_pathname(sfd);
  sock.sun_family = AF_UNIX;
  strcpy(sock.sun_path, addr);

  unlink(addr);
  len = sizeof(sock.sun_family) + strlen(addr);
  if (bind(sfd, &sock, len) < 0) {
    perror("ocr_fork: bind");
    close(sfd);
    return -1;
  }

  if (listen(sfd, 1) < 0) {
    perror("ocr_fork: listen");
    unlink(addr);
    close(sfd);
    return -1;
  }

  pkt[0] = 'O';
  pkt[3] = sfd;
  write(UnixPipeOut, pkt, 4);

  read(UnixPipeIn, pkt, 4);
  if (pkt[3] == 1) {
  retry:
    SETJMP(-1);
    S_TOUT_TIME(nsfd = accept(sfd, NULL, NULL), 20);
    if (nsfd < 0) {
      if (errno == EINTR) {
        goto retry;
      } else {
        perror("ocr_fork: accept");
        unlink(addr);
        close(sfd);
        return -1;
      }
    }
    close(sfd);
    unlink(addr);
    OCR_procID = pkt[1] << 8 | pkt[2];
    return (nsfd);
  } else {
    close(sfd);
    unlink(addr);
    return -1;
  }
}

/*
 * Change blocking mode of a file descriptor.
 */

static int ocr_block_mode(fd, doblock) int fd;
int doblock;
{
  int flags;

  if (fd < 0) return 0;

  flags = fcntl(fd, F_GETFL, 0);
  if (flags < 0) return 0;

  if (doblock) {
    flags &= ~FNDELAY;
  } else {
    flags |= FNDELAY;
  }

  if (fcntl(fd, F_SETFL, flags) < 0) return 0;

  return 1;
}

/*
 * Cleanup routines
 */

static void ocr_device_reset() {
  if (OCR_sock >= 0) {
    u_char pkt[PKTLEN];

    pkt[0] = 'A';
    pkt[1] = pkt[2] = 0;
    write(OCR_sock, pkt, sizeof(pkt));

    sleep(1);
  }
  return;
}

static int ocr_wait() {
  u_char pkt[4];
  int status;

  if (OCR_procID > 0) {
    pkt[0] = 'w';
    pkt[1] = OCR_procID >> 8 & 0xFF;
    pkt[2] = OCR_procID & 0xFF;

    write(UnixPipeOut, pkt, sizeof(pkt));
    read(UnixPipeIn, pkt, sizeof(pkt));

    status = pkt[0] << 24 | pkt[1] << 16 | pkt[2] << 8 | pkt[3];

    if (status != 0 && (WIFSIGNALED(status) || WIFEXITED(status))) {
      return 1;
    } else {
      return 0;
    }
  }
  return 1;
}

static void ocr_close() {
  int status, pid;

  if (OCR_sock >= 0) {
    ocr_device_reset();
    (void)shutdown(OCR_sock, 2);
  }

  OCR_sock = shifted_OCR_sock = -1;
  ocr_clr_handler();

  if (OCR_procID > 0) {
    if (ocr_wait() == 0) {
      int i;
      kill(OCR_procID, SIGUSR1);
      for (i = 0; i < 10; i++) {
        if (ocr_wait()) break;
      }
    }
    OCR_procID = -1;
  }
  return;
}

/*
 * Subr OCR_COMM: comm = OCR_SCAN
 *
 * Issue 'S' command to start scanning.  'S' commmand returns immediatedly
 * without waiting device to finish scanning.
 */

static int ocr_scan(sp) struct ocr_scan_para *sp;
{
  int cnt;
  u_char pkt[PKTLEN];

  pkt[0] = 'S';
  pkt[1] = 0;
  pkt[2] = sizeof(struct ocr_scan_para);

  if (write(OCR_sock, pkt, sizeof(pkt)) != sizeof(pkt)) { return 0; }
  if (write(OCR_sock, (char *)sp, sizeof(struct ocr_scan_para)) != sizeof(struct ocr_scan_para)) {
    return 0;
  }

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) return -1;
    }
    return 0;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 5);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    SET_WAIT_FLG(OCR_ST_SCANNING);
    return 1;
  } else {
    return 0;
  }
}

/*
 * Subr OCR_COMM: comm = OCR_IMG_INFO
 *
 * Issue 'I' command to get an information about the image being uploaded.
 * 'I' commmand returns immediatedly without waiting OCR process to
 * finish its work.
 */

static int ocr_iminfo(up) struct ocr_up_para *up;
{
  int i, cnt;
  u_char pkt[PKTLEN];

  pkt[0] = 'I';
  pkt[1] = 0;
  pkt[2] = sizeof(struct ocr_up_para);

  if (write(OCR_sock, pkt, sizeof(pkt)) != sizeof(pkt)) { return 0; }
  if (write(OCR_sock, (char *)up, sizeof(struct ocr_up_para)) != sizeof(struct ocr_up_para)) {
    return 0;
  }

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) return -1;
    }
    return 0;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 5);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    SET_WAIT_FLG(OCR_ST_UPLDING);
    return 1;
  } else {
    return 0;
  }
}

/*
 * Subr OCR_COMM: comm = OCR_SET_RPARA
 *
 * Issue 'P' command to set read parameters.
 */

static int ocr_set_rpara(pp, num) register u_char *pp;
register int num;
{
  register int cnt;
  u_char pkt[PKTLEN];

  pkt[0] = 'P';
  num = num * sizeof(struct ocr_read_para);
  pkt[1] = num >> 8 & 0xFF;
  pkt[2] = num & 0xFF;

  if (write(OCR_sock, pkt, sizeof(pkt)) != sizeof(pkt)) { return 0; }
  do {
    cnt = write(OCR_sock, (char *)pp, num);
    if (cnt < 0) {
      return 0;
    } else {
      num -= cnt;
      pp += cnt;
    }
  } while (num > 0);

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) return -1;
    }
    return 0;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 15);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    return 1;
  } else {
    return 0;
  }
}

/*
 * Subr OCR_COMM: comm = OCR_CLR_RPARA
 *
 * Issue 'C' command to clear all read parameters.
 */

static int ocr_clr_rpara() {
  register int cnt;
  u_char pkt[PKTLEN];

  pkt[0] = 'C';
  pkt[1] = pkt[2] = 0;

  if (write(OCR_sock, pkt, sizeof(pkt)) != sizeof(pkt)) { return 0; }

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) return -1;
    }
    return 0;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 15);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    return 1;
  } else {
    return 0;
  }
}

/*
 * Subr OCR_COMM: comm = OCR_READ
 *
 * Issue 'R' command to start reading.
 * 'R' commmand returns immediatedly without waiting OCR process to
 * finish its work.
 */

static int ocr_read() {
  register int cnt;
  u_char pkt[PKTLEN];

  pkt[0] = 'R';
  pkt[1] = pkt[2] = 0;

  if (write(OCR_sock, pkt, sizeof(pkt)) != sizeof(pkt)) { return 0; }

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) return -1;
    }
    return 0;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 15);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    SET_WAIT_FLG(OCR_ST_READING)
    return 1;
  } else {
    return 0;
  }
}

/*
 * SIGUSR1 handler.
 *
 * If one of time consuming work is finished by OCR process, SIGUSR1 is signalled.
 * Accoding to the waiting reason, do appropriate work, then to notify Lisp.
 */

static void ocr_sig_handler(sig, code, scp) int sig, code;
struct sigcontext *scp;
{
  if (OCR_sock < 0) return;

  switch (WAITING_REASON) {
    case OCR_ST_SCANNING: ocr_scan_finish(); break;

    case OCR_ST_UPLDING: ocr_img_upld_finish(); break;

    case OCR_ST_READING: ocr_read_finish(); break;

    default: SET_WAIT_FLG(OCR_ST_FAIL);
  }
  ocr_irq();
  return;
}

static void ocr_set_handler() {
  struct sigvec sv;

  sv.sv_flags = sv.sv_mask = 0;
  sv.sv_handler = ocr_sig_handler;
  sigvec(SIGUSR1, &sv, NULL);
  return;
}

static void ocr_clr_handler() {
  struct sigvec sv;
  extern void panicuraid();

  sv.sv_flags = sv.sv_mask = 0;
  sv.sv_handler = panicuraid;
  sigvec(SIGUSR1, &sv, NULL);
  return;
}

/*
 * Handle SIGUSR1 interrupt if state is scanning
 */

static void ocr_scan_finish() {
  int cnt;
  u_char pkt[PKTLEN];

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) {
        SET_WAIT_FLG(OCR_ST_PROC_DEAD);
        break;
      }
    }
    return;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 5);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    CLR_WAIT_FLG;
  } else {
    SET_WAIT_FLG(OCR_ST_FAIL);
  }
  return;
}

/*
 * Handle SIGUSR1 interrupt if state is image uploading
 */

static void ocr_img_upld_finish() {
  int cnt;
  u_char pkt[PKTLEN];

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) {
        SET_WAIT_FLG(OCR_ST_PROC_DEAD);
        break;
      }
    }
    return;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 5);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    S_TOUT_TIME(cnt = read(OCR_sock, (char *)OCR_iminfo_block, sizeof(struct ocr_image_info)), 5);
    if (cnt == sizeof(struct ocr_image_info)) {
      CLR_WAIT_FLG;
      OCR_image_size = OCR_iminfo_block->size;
    } else {
      SET_WAIT_FLG(OCR_ST_FAIL);
    }
  } else {
    SET_WAIT_FLG(OCR_ST_FAIL);
  }
  return;
}

/*
 * Handle SIGUSR1 interrupt if state is reading
 */

static void ocr_read_finish() {
  int cnt;
  u_char pkt[PKTLEN];

  IF_TIMEOUT({
    int i;
    for (i = 0; i < 10; i++) {
      if (ocr_wait()) {
        SET_WAIT_FLG(OCR_ST_PROC_DEAD);
        break;
      }
    }
    return;
  });

  S_TOUT_TIME(cnt = read(OCR_sock, pkt, sizeof(pkt)), 5);

  if (cnt == sizeof(pkt) && pkt[0] == 1) {
    CLR_WAIT_FLG;
  } else {
    SET_WAIT_FLG(OCR_ST_FAIL);
  }
  return;
}

/*
 * Set up the interrupt stuff and issue a requst.
 */

static void ocr_irq() {
  u_int *flagp;
  extern LispPTR *IOINTERRUPTFLAGS_word;
  extern LispPTR *IOINTERRUPTSTATE_word;
  extern LispPTR *PENDINGINTERRUPT68k;

  if (OCR_sock < 0) return;

  flagp = (u_int *)Addr68k_from_LADDR(*IOINTERRUPTFLAGS_word);
  *flagp = shifted_OCR_sock;

  ((INTSTAT *)Addr68k_from_LADDR(*INTERRUPTSTATE_word))->IOInterrupt = 1;

  *PENDINGINTERRUPT68k = ATOM_T;
  Irq_Stk_End = Irq_Stk_Check = 0;

  return;
}

/*
 * Bulk data transfer
 */

static int ocr_bulk_read(fd, buf, tout) int fd, tout;
register char *buf;
{
  register u_int cnt, len = 0;
  struct bd_header hd;

  SETJMP(-1);

  while (1) {
    S_TOUT_TIME(cnt = read(fd, &hd, sizeof(struct bd_header)), tout);
    if (cnt < 0) return -1;
    if (hd.len == 0) return ((hd.cont == BD_LAST) ? len : -1);
    do {
      S_TOUT_TIME(cnt = read(fd, buf, hd.len), tout);
      if (cnt < 0) return -1;
      hd.len -= cnt;
      len += cnt;
      buf += cnt;
    } while (hd.len > 0);
    if (hd.cont == BD_LAST) return len;
  }
}

static LispPTR ocr_get_read_result(fd) int fd;
{
  register u_int cnt, len, buflen;
  struct bd_header hd;
  u_char *buf, *ptr;
  LispPTR val;

  SETJMP(NIL);

  S_TOUT_TIME(cnt = read(fd, &hd, sizeof(struct bd_header)), 1);
  val = 0;
  ptr = buf = NULL;
  buflen = 0;

  while (hd.len > 0) {
    if (buflen > 0) {
      len = MIN(hd.len, buflen);
      do {
        S_TOUT_TIME(cnt = read(fd, ptr, len), 10);
        if (cnt < 0) return (NIL);
        hd.len -= cnt;
        len -= cnt;
        buflen -= cnt;
        ptr += cnt;
      } while (len > 0);
      if (hd.len > 0) {
        continue;
      } else if (hd.cont != BD_CONT) {
        break;
      } else {
        S_TOUT_TIME(cnt = read(fd, &hd, sizeof(struct bd_header)), 1);
        continue;
      }
    } else {
      ptr = buf = (u_char *)createcell68k(TYPE_VMEMPAGEP);
      if (buf == NULL) {
        return (NIL);
      } else {
        val = cons(LADDR_from_68k(buf), val);
        buflen = 512;
      }
    }
  }
  return (val);
}

/*
 * OCR specific code conversion
 */

static u_short jis0[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x0020, 0x0021, 0x0022, 0x0023, 0x00A4, 0x0025, 0x0026, 0x0027, 0x0028,
                            0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,

                            0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038,
                            0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,

                            0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048,
                            0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,

                            0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058,
                            0x0059, 0x005A, 0x005B, 0x00A5, 0x005D, 0x005E, 0x005F,

                            0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068,
                            0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,

                            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078,
                            0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2123, 0x2156, 0x2157, 0x2122, 0x00B7, 0x2572, 0x2521, 0x2523,
                            0x2525, 0x2527, 0x2529, 0x2563, 0x2565, 0x2567, 0x2544,

                            0x213C, 0x2522, 0x2524, 0x2526, 0x2528, 0x252A, 0x252B, 0x252D, 0x252F,
                            0x2531, 0x2533, 0x2535, 0x2537, 0x2539, 0x253B, 0x253D,

                            0x253F, 0x2541, 0x2544, 0x2546, 0x2548, 0x254A, 0x254B, 0x254C, 0x254D,
                            0x254E, 0x254F, 0x2552, 0x2555, 0x2558, 0x255B, 0x255E,

                            0x255F, 0x2560, 0x2561, 0x2562, 0x2564, 0x2566, 0x2568, 0x2569, 0x256A,
                            0x256B, 0x256C, 0x256D, 0x256F, 0x2573, 0x212B, 0x212C,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis1[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2121, 0x2122, 0x2123, 0x002C, 0x002E, 0x00B7, 0x003A, 0x003B,
                            0x003F, 0x0021, 0x212B, 0x212C, 0x00C2, 0x00C1, 0x00C8,

                            0x00C3, 0x2223, 0x00CC, 0x2133, 0x2134, 0x2135, 0x2136, 0x2137, 0x2138,
                            0x2139, 0x213A, 0x213B, 0x213C, 0xEF24, 0x213E, 0x002F,

                            0x005C, 0x007E, 0x003D, 0x007C, 0x2144, 0x003A, 0x00A9, 0x0027, 0x00AA,
                            0x00BA, 0x0028, 0x0029, 0x214C, 0x214D, 0x005B, 0x005D,

                            0x007B, 0x007D, 0xEF32, 0xEF33, 0x00AB, 0x00BB, 0x2156, 0x2157, 0x2158,
                            0x2159, 0x215A, 0x215B, 0x002B, 0x002D, 0x00B1, 0x00B4,

                            0x00B8, 0x003D, 0x2162, 0x003C, 0x003E, 0x2165, 0x2166, 0x2167, 0x2168,
                            0x2169, 0x216A, 0x00B0, 0x216C, 0x216D, 0x216E, 0x00A5,

                            0x00A4, 0x00A2, 0x00A3, 0x0025, 0x0023, 0x0026, 0x002A, 0x0040, 0x00A7,
                            0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis2[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2221, 0x2222, 0x2223, 0x2224, 0x2225, 0x2226, 0x2227, 0x2228,
                            0x2229, 0x00AE, 0x00AC, 0x00AD, 0x00AF, 0x222E, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0xEF4A, 0xEF4C, 0xEF59, 0xEF58, 0xEF5B, 0xEF5A,

                            0xEF57, 0xEF56, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0xEFB6, 0xEFB7, 0xEF6A, 0xEF4F, 0xEF4E, 0xEFB5,

                            0xEFB4, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0xEF6C, 0xEF70, 0x2223, 0xEFBA,

                            0xEFB9, 0xEF72, 0x2223, 0xEF42, 0xEF43, 0x2223, 0x2223, 0xEF71, 0xEF6F,
                            0xEF75, 0x226A, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0xF128, 0xEF41, 0x2223, 0x2223, 0x2223, 0xEF30, 0xEF31,
                            0x00B0, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis3[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038,
                            0x0039, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048,
                            0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,

                            0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058,
                            0x0059, 0x005A, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068,
                            0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,

                            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078,
                            0x0079, 0x007A, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis6[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2641, 0x2642, 0x2644, 0x2645, 0x2646, 0x2649, 0x264A, 0x264B,
                            0x264C, 0x264D, 0x264E, 0x264F, 0x2650, 0x2651, 0x2652,

                            0x2653, 0x2655, 0x2656, 0x2658, 0x2659, 0x265A, 0x265B, 0x265C, 0x265D,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2661, 0x2662, 0x2664, 0x2665, 0x2666, 0x2669, 0x266A, 0x266B,
                            0x266C, 0x266D, 0x266E, 0x266F, 0x2670, 0x2671, 0x2672,

                            0x2673, 0x2675, 0x2676, 0x2678, 0x2679, 0x267A, 0x267B, 0x267C, 0x267D,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis84[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x7521, 0x7522, 0x7523, 0x7524, 0x7525, 0x7526, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis8[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0xEF69,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0xF128, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x7421, 0x7421, 0xEFFC, 0xEFFC, 0x2220,
                            0x2220, 0xEFA8, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis9[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0xEFD1, 0xEFD2, 0xEFD3, 0xEFD4, 0xEFD5,
                            0xEFD6, 0xEFD7, 0xEFD8, 0xEFD9, 0xEFDA, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0xEFD1, 0xEFD2, 0xEFD3, 0xEFD4, 0xEFD5, 0xEFD6, 0xEFD7,

                            0xEFD8, 0xEFD9, 0xEFDA, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0xEFC2,

                            0xEFC3, 0xEFC4, 0x2223, 0xEFC6, 0xEFC7, 0xEFC8, 0xEFC9, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                            0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis10[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x7409, 0x7421, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

static u_short jis14[256] = {0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2122, 0x2123, 0x2124, 0x2125, 0x2223, 0x2223, 0x213C, 0xEF24,
                             0x213E, 0x213B, 0x2223, 0x2223, 0x2144, 0x2145, 0x00A9,

                             0x0027, 0x00AA, 0x00BA, 0x0028, 0x0029, 0x214C, 0x214D, 0x005B, 0x005D,
                             0x007B, 0x007D, 0xEF32, 0xEF33, 0x00AB, 0x00BB, 0x2156,

                             0x2157, 0x2223, 0x2223, 0x215A, 0x215B, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,

                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223,
                             0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223, 0x2223

};

#define SJIS_TO_JIS(hp, lp)                \
  {                                        \
    *(hp) -= (*(hp) > 0x9F) ? 0xB1 : 0x71; \
    *(hp) = (*(hp) << 1) + 1;              \
    if (*(lp) > 0x9E) {                    \
      *(lp) -= 0x7E;                       \
      *(hp) += 1;                          \
    } else if (*(lp) > 0x7E) {             \
      *(lp) -= 0x20;                       \
    } else {                               \
      *(lp) -= 0x1F;                       \
    }                                      \
  }

static void ocr_code_conv(ptr, len) register u_char *ptr;
register int len;
{
  while (len > 0) {
    if (*ptr == 0xFF) { /* ASCII & Hankaku-kana */
      *(u_short *)ptr = jis0[*(ptr + 1)];
    } else {
      SJIS_TO_JIS(ptr, ptr + 1);
      switch (*ptr) {
        case 0X21: /* 1 Ku */ *(u_short *)ptr = jis1[*(ptr + 1)]; break;
        case 0X22: /* 2 Ku */ *(u_short *)ptr = jis2[*(ptr + 1)]; break;
        case 0X23: /* 3 Ku */ *(u_short *)ptr = jis3[*(ptr + 1)]; break;
        case 0X26: /* 6 Ku */ *(u_short *)ptr = jis6[*(ptr + 1)]; break;
        case 0X28: /* 8 Ku */ *(u_short *)ptr = jis8[*(ptr + 1)]; break;
        case 0X29: /* 9 Ku */ *(u_short *)ptr = jis9[*(ptr + 1)]; break;
        case 0X2A: /* 10 Ku */ *(u_short *)ptr = jis10[*(ptr + 1)]; break;
        case 0X2E: /* 14 Ku */ *(u_short *)ptr = jis14[*(ptr + 1)]; break;
        case 0X74: /* 84 Ku */ *(u_short *)ptr = jis84[*(ptr + 1)]; break;
        default: break;
      }
    }
    ptr += 2;
    len--;
  }
}

#endif /* OCR */
